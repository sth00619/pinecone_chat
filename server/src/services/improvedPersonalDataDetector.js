// server/src/services/ImprovedPersonalDataDetector.js
const pool = require('../config/database');
const ImprovedScheduleStorage = require('./improvedScheduleStorage');
const OpenAI = require('openai');

class ImprovedPersonalDataDetector {
  constructor() {
    this.scheduleStorage = new ImprovedScheduleStorage();
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  // Ìñ•ÏÉÅÎêú ÏùºÏ†ï Ï∂îÏ∂ú Î∞è Ï†ÄÏû• (ÏßàÎ¨∏ Î∂ÑÎ•ò Í∞úÏÑ†)
  async extractAndSaveSchedules(text, userId, chatRoomId) {
    try {
      // Î®ºÏ†Ä Í∞ÑÎã®Ìïú Ìå®ÌÑ¥ÏúºÎ°ú Ï°∞Ìöå ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
      const isQueryPattern = this.isDefinitelyQuery(text);
      if (isQueryPattern) {
        return {
          hasPersonalInfo: false,
          isScheduleRegistration: false,
          isScheduleQuery: true,
          schedules: [],
          response: null
        };
      }

      const prompt = `
Îã§Ïùå Î©îÏãúÏßÄÎ•º Ï†ïÌôïÌûà Î∂ÑÎ•òÌï¥Ï£ºÏÑ∏Ïöî:
"${text}"

Í∑úÏπô:
1. Ï°∞Ìöå/ÏßàÎ¨∏ (isQuery: true): "ÏïåÎ†§Ï§ò", "Î≠ê ÏûàÏñ¥", "ÌôïÏù∏", "Î≥¥Ïó¨Ï§ò", "ÎåÄÌï¥ÏÑú" Îì±Ïù¥ Ìè¨Ìï®Îêú Í≤ΩÏö∞
2. Îì±Î°ù (isSchedule: true): Íµ¨Ï≤¥Ï†ÅÏù∏ ÎÇ†ÏßúÏôÄ ÌôúÎèôÏù¥ Î™ÖÏãúÎêú Í≤ΩÏö∞

JSON ÌòïÏãù:
{
  "isSchedule": true/false,
  "isQuery": true/false,
  "confidence": 0.0-1.0,
  "schedules": [
    {
      "title": "ÌôúÎèôÎ™Ö",
      "date": "ÎÇ†Ïßú",
      "confidence": 0.0-1.0
    }
  ]
}

ÏòàÏãú:
"7Ïõî ÏùºÏ†ïÏóê ÎåÄÌï¥ÏÑú ÏïåÎ†§Ï§ò" ‚Üí isQuery: true, isSchedule: false
"9Ïõî 1ÏùºÏóê Ïä§ÌÇ§Ïû• Í∞ÄÍ∏∞Î°ú ÌñàÏñ¥" ‚Üí isQuery: false, isSchedule: true
`;

      const response = await this.openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.1, // Îçî ÎÇÆÏùÄ temperatureÎ°ú ÏùºÍ¥ÄÏÑ± Ìñ•ÏÉÅ
        max_tokens: 300,
        response_format: { type: "json_object" }
      });

      const result = JSON.parse(response.choices[0].message.content);
      
      console.log('ü§ñ AI Classification Result:', {
        text: text.substring(0, 50),
        isSchedule: result.isSchedule,
        isQuery: result.isQuery,
        confidence: result.confidence
      });
      
      // ÏùºÏ†ï Îì±Î°ùÏù∏ Í≤ΩÏö∞ (ÎÜíÏùÄ Ïã†Î¢∞ÎèÑÏóêÏÑúÎßå)
      if (result.isSchedule && !result.isQuery && result.confidence > 0.8) {
        console.log(`üìù Saving ${result.schedules?.length || 0} integrated schedules...`);
        
        const validSchedules = (result.schedules || []).filter(s => s.confidence > 0.7);
        if (validSchedules.length > 0) {
          const savedSchedules = await this.scheduleStorage.saveMultipleSchedules(
            userId, 
            chatRoomId, 
            validSchedules,
            text
          );
          
          return {
            hasPersonalInfo: true,
            isScheduleRegistration: true,
            isScheduleQuery: false,
            schedules: savedSchedules,
            response: this.generateRegistrationResponse(savedSchedules)
          };
        }
      }
      
      // ÏùºÏ†ï Ï°∞ÌöåÏù∏ Í≤ΩÏö∞
      if (result.isQuery && !result.isSchedule) {
        return {
          hasPersonalInfo: false,
          isScheduleRegistration: false,
          isScheduleQuery: true,
          schedules: [],
          response: null
        };
      }
      
      // Î™®Ìò∏Ìïú Í≤ΩÏö∞ Ï°∞ÌöåÎ°ú Ï≤òÎ¶¨
      console.log('‚ö†Ô∏è Ambiguous classification, treating as general message');
      return {
        hasPersonalInfo: false,
        isScheduleRegistration: false,
        isScheduleQuery: false,
        schedules: [],
        response: null
      };
      
    } catch (error) {
      console.error('Schedule extraction error:', error);
      return {
        hasPersonalInfo: false,
        isScheduleRegistration: false,
        isScheduleQuery: false,
        schedules: [],
        response: null
      };
    }
  }

  // Î™ÖÌôïÌïú Ï°∞Ìöå Ìå®ÌÑ¥ ÌôïÏù∏
  isDefinitelyQuery(text) {
    const definiteQueryPatterns = [
      /ÏùºÏ†ï.*ÏïåÎ†§/, /ÏùºÏ†ï.*Î≠ê/, /ÏùºÏ†ï.*Ïûà/, /ÏùºÏ†ï.*Î≥¥Ïó¨/, /ÏùºÏ†ï.*ÌôïÏù∏/,
      /.*ÏùºÏ†ï.*ÎåÄÌï¥ÏÑú/, /.*ÏùºÏ†ï.*Î¨ºÏñ¥/, /.*ÏùºÏ†ï.*Í∂ÅÍ∏à/,
      /Ïä§ÏºÄÏ§Ñ.*ÏïåÎ†§/, /Ïä§ÏºÄÏ§Ñ.*Î≠ê/, /Ïä§ÏºÄÏ§Ñ.*Ïûà/,
      /(\d{1,2}Ïõî).*ÏùºÏ†ï.*ÏïåÎ†§/, /(\d{1,2}Ïõî).*ÏùºÏ†ï.*Î≠ê/,
      /ÎÇòÏùò.*ÏùºÏ†ï/, /ÎÇ¥.*ÏùºÏ†ï.*Î≠ê/
    ];
    
    return definiteQueryPatterns.some(pattern => pattern.test(text));
  }

  // ÏûêÏó∞Ïä§Îü¨Ïö¥ Îì±Î°ù ÏùëÎãµ ÏÉùÏÑ±
  generateRegistrationResponse(savedSchedules) {
    if (savedSchedules.length === 0) {
      return "ÏùºÏ†ïÏùÑ Ï†ÄÏû•ÌïòÎäîÎç∞ Î¨∏Ï†úÍ∞Ä ÏûàÏóàÏäµÎãàÎã§.";
    }

    if (savedSchedules.length === 1) {
      const schedule = savedSchedules[0];
      const responses = [
        `ÏïåÍ≤†ÏäµÎãàÎã§! ${schedule.title}${schedule.date ? ` (${schedule.date})` : ''}Î•º Í∏∞ÏñµÌï¥ÎëêÍ≤†ÏäµÎãàÎã§. üòä`,
        `ÎÑ§, ${schedule.title} ÏùºÏ†ïÏùÑ Ï†ÄÏû•ÌñàÏäµÎãàÎã§!${schedule.date ? ` ${schedule.date}Ïóê ÏûäÏßÄ ÎßêÍ≥† Ï±ôÍ≤®Ï£ºÏÑ∏Ïöî! ‚è∞` : ''}`,
        `${schedule.title} ÏùºÏ†ï Îì±Î°ù ÏôÑÎ£åÌñàÏäµÎãàÎã§!${schedule.time ? ` ${schedule.time}Ïóê ÎßûÏ∂∞ÏÑú Ï§ÄÎπÑÌïòÏãúÎ©¥ ÎêòÍ≤†ÎÑ§Ïöî! üëç` : ''}`,
        `Ï¢ãÏäµÎãàÎã§! ${schedule.title}${schedule.date ? ` (${schedule.date})` : ''} ÏùºÏ†ïÏùÑ Ïûò Í∏∞ÏñµÌï¥ÎëêÍ≤†ÏäµÎãàÎã§. üìù`
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    // Ïó¨Îü¨ ÏùºÏ†ïÏù∏ Í≤ΩÏö∞
    const scheduleList = savedSchedules.map(s => 
      `${s.title}${s.date ? ` (${s.date})` : ''}`
    ).join(', ');
    
    return `ÎÑ§, Ï¥ù ${savedSchedules.length}Í∞úÏùò ÏùºÏ†ïÏùÑ Ï†ÄÏû•ÌñàÏäµÎãàÎã§! (${scheduleList}) üìù ÌïÑÏöîÌï† Îïå Ïñ∏Ï†úÎì† ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî! üòä`;
  }

  // ÏõîÎ≥Ñ ÏùºÏ†ï Ï°∞Ìöå
  async getMonthlySchedules(userId, month, year = null) {
    return await this.scheduleStorage.getMonthlySchedules(userId, month, year);
  }

  // Î©îÏù∏ Ï≤òÎ¶¨ Ìï®Ïàò
  async processMessage(message, userId, chatRoomId) {
    try {
      console.log('üîç Processing message for integrated schedules:', message);
      
      const result = await this.extractAndSaveSchedules(message, userId, chatRoomId);
      
      if (result.isScheduleRegistration) {
        console.log(`‚úÖ Registered ${result.schedules.length} integrated schedule(s)`);
      } else if (result.isScheduleQuery) {
        console.log('üìã Schedule query detected');
      }
      
      return result;
      
    } catch (error) {
      console.error('Error processing message:', error);
      return {
        hasPersonalInfo: false,
        isScheduleRegistration: false,
        isScheduleQuery: false,
        schedules: [],
        response: null
      };
    }
  }

  // ÏÇ¨Ïö©Ïûê Ïª®ÌÖçÏä§Ìä∏ Íµ¨Ï∂ï (Í∏∞Ï°¥ ÏãúÏä§ÌÖúÍ≥º Ìò∏Ìôò)
  async buildUserContext(userId, currentMessage) {
    try {
      // Í∏∞Î≥∏ Ïª®ÌÖçÏä§Ìä∏ Íµ¨Ï°∞
      const context = {
        schedules: [],
        preferences: [],
        goals: [],
        reminders: [],
        birthdays: [],
        locations: [],
        isScheduleQuery: this.isScheduleQuery(currentMessage),
        relevantSchedules: [],
        hasPersonalData: false
      };

      // ÏùºÏ†ï Îç∞Ïù¥ÌÑ∞ Î°úÎìú (ÏÉàÎ°úÏö¥ ÏãúÏä§ÌÖú ÏÇ¨Ïö©)
      try {
        // DBÏóêÏÑú ÏÇ¨Ïö©ÏûêÏùò Î™®Îì† ÌôúÏÑ± ÏùºÏ†ï Ï°∞Ìöå
        const query = `
          SELECT id, data_key, encrypted_value, context, iv, auth_tag, created_at,
                 schedule_title, schedule_date, schedule_time, schedule_location
          FROM user_personal_data 
          WHERE user_id = ? AND data_type = 'schedule' AND is_active = 1
          ORDER BY created_at DESC
          LIMIT 20
        `;
        
        const [rows] = await pool.query(query, [userId]);
        
        if (rows.length > 0) {
          // ÏùºÏ†ï Îç∞Ïù¥ÌÑ∞ ÌååÏã±
          context.schedules = rows.map(row => {
            let title, date, time, location;
            
            // ÏÉà Ïª¨ÎüºÏù¥ ÏûàÎäî Í≤ΩÏö∞
            if (row.schedule_title) {
              title = row.schedule_title;
              date = row.schedule_date;
              time = row.schedule_time;
              location = row.schedule_location;
            } else {
              // contextÏóêÏÑú Ï∂îÏ∂ú
              try {
                const contextData = JSON.parse(row.context || '{}');
                title = contextData.schedule_title || contextData.title || row.data_key || 'ÏùºÏ†ï';
                date = contextData.schedule_date || contextData.date;
                time = contextData.schedule_time || contextData.time;
                location = contextData.schedule_location || contextData.location;
              } catch (error) {
                title = row.data_key || 'ÏùºÏ†ï';
                date = null;
                time = null;
                location = null;
              }
            }
            
            return {
              id: row.id,
              title: title,
              date: date,
              time: time,
              location: location,
              datetime: date && time ? `${date} ${time}` : date || '',
              content: title,
              createdAt: row.created_at
            };
          });
          
          context.hasPersonalData = context.schedules.length > 0;
        }
      } catch (error) {
        console.warn('Error loading schedule context:', error);
      }

      // Í¥ÄÎ†® ÏùºÏ†ï Ï∞æÍ∏∞
      if (context.isScheduleQuery && context.schedules.length > 0) {
        context.relevantSchedules = this.findRelevantSchedules(currentMessage, context.schedules);
      }

      console.log(`üìä Context built: schedules=${context.schedules.length}, relevant=${context.relevantSchedules.length}`);
      return context;

    } catch (error) {
      console.error('Error building user context:', error);
      return {
        schedules: [],
        preferences: [],
        goals: [],
        reminders: [],
        birthdays: [],
        locations: [],
        isScheduleQuery: false,
        relevantSchedules: [],
        hasPersonalData: false
      };
    }
  }

  // Í¥ÄÎ†® ÏùºÏ†ï Ï∞æÍ∏∞
  findRelevantSchedules(userMessage, schedules) {
    if (!Array.isArray(schedules) || schedules.length === 0) {
      return [];
    }

    const queryWords = userMessage.toLowerCase().split(/\s+/);
    const relevant = schedules.filter(schedule => {
      const scheduleText = `${schedule.title} ${schedule.date || ''} ${schedule.location || ''}`.toLowerCase();
      return queryWords.some(word => scheduleText.includes(word));
    });

    return relevant.slice(0, 5);
  }

  // ÏùºÏ†ï Í¥ÄÎ†® ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏ (ÎàÑÎùΩÎêú Î©îÏÑúÎìú Ï∂îÍ∞Ä)
  isScheduleQuery(message) {
    const queryPatterns = [
      /ÏùºÏ†ï.*Î≠ê/, /ÏùºÏ†ï.*Ïûà/, /Î¨¥Ïä®.*ÏùºÏ†ï/, /Ïñ¥Îñ§.*ÏùºÏ†ï/,
      /Ïä§ÏºÄÏ§Ñ.*Î≠ê/, /Ïä§ÏºÄÏ§Ñ.*Ïûà/, /Î¨¥Ïä®.*Ïä§ÏºÄÏ§Ñ/,
      /(Ïò§Îäò|ÎÇ¥Ïùº|Ïù¥Î≤àÏ£º|Îã§ÏùåÏ£º).*ÏùºÏ†ï/,
      /(\d{1,2}Ïõî).*ÏùºÏ†ï/, /ÏùºÏ†ï.*(\d{1,2}Ïõî)/,
      /ÎÇ¥.*ÏùºÏ†ï/, /ÎÇòÏùò.*ÏùºÏ†ï/
    ];
    
    return queryPatterns.some(pattern => pattern.test(message));
  }

  // Ïõî Ï∂îÏ∂ú
  extractMonthFromMessage(message) {
    const monthPattern = /(\d{1,2})Ïõî/;
    const match = message.match(monthPattern);
    if (match) {
      const month = parseInt(match[1]);
      if (month >= 1 && month <= 12) {
        return month;
      }
    }
    return null;
  }
}

module.exports = ImprovedPersonalDataDetector;